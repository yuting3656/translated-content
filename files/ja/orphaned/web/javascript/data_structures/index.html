---
title: JavaScript のデータ型とデータ構造
slug: orphaned/Web/JavaScript/Data_structures
tags:
  - Beginner
  - Guide
  - JavaScript
  - Types
translation_of: Web/JavaScript/Data_structures
original_slug: Web/JavaScript/Data_structures
---
<div>{{jsSidebar("More")}}</div>

<p>あらゆるプログラミング言語は、それぞれ異なったデータ構造を持っています。この記事では、JavaScript で使用可能な組み込みデータ構造の一覧と、他のデータ構造の構築にも使えるように、それらがどのような性質を持ち合わせているかについて述べることにします。また可能である場合は、他のプログラミング言語におけるデータ構造との対比も行います。</p>

<h2 id="Dynamic_typing" name="Dynamic_typing">動的型付け</h2>

<p>JavaScript は<em>弱い型付け</em>あるいは<em>動的型付け</em>の言語です。JavaScript では、変数が直接的に特定のデータ型に関連付けられているわけではなく、どの変数にもあらゆる型の値を代入(および再代入)できます。</p>

<pre class="brush: js notranslate">let foo = 42;    // foo は数値です
foo     = 'bar'; // foo は文字列です
foo     = true;  // foo は真偽値です
</pre>

<h2 id="Data_and_Structure_types" name="Data_and_Structure_types">データと構造型</h2>

<p>最新の ECMAScript 標準では、次の 9 つの型が定義されています。</p>

<ul>
 <li><strong>データ型</strong> <a href="/ja/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a> 演算子で<a href="/ja/docs/Glossary/Primitive">プリミティブ</a>と判定できる 6 種類。

  <ul>
   <li><a href="/ja/docs/Glossary/Undefined">undefined</a> : <code>typeof instance === "<strong>undefined</strong>"</code></li>
   <li><a href="/ja/docs/Glossary/Boolean">Boolean</a> : <code>typeof instance === "boolean"</code></li>
   <li><a href="/ja/docs/Glossary/Number">Number</a> : <code>typeof instance === "number"</code></li>
   <li><a href="/ja/docs/Glossary/String">String</a> : <code>typeof instance === "string"</code></li>
   <li><a href="/ja/docs/Glossary/BigInt">BigInt</a><span> : </span><code>typeof instance === "bigint"</code></li>
   <li><a href="/ja/docs/Glossary/Symbol">Symbol</a><span> : </span><code>typeof instance === "symbol"</code></li>
  </ul>
 </li>
 <li><strong>構造型</strong>
  <ul>
   <li><a href="/ja/docs/Glossary/Object">Object</a><span> : </span><code>typeof instance === "<strong>object</strong>"</code> データではありませんが、<a href="/ja/docs/Learn/JavaScript/Objects#The_Constructor">構築</a>された任意のオブジェクトインスタンスのための特別な<strong>構造型</strong>で、データ構造としても使用されます。new {{jsxref("Object")}}, new {{jsxref("Array")}}, new {{jsxref("Map")}}, new {{jsxref("Set")}}, new {{jsxref("WeakMap")}}, new {{jsxref("WeakSet")}}, new {{jsxref("Date")}} など <a href="/ja/docs/Web/JavaScript/Reference/Operators/new">new キーワード</a>で作成されたほぼすべてのもの。</li>
   <li><a href="/ja/docs/Glossary/Function">Function</a><span> : 非データ構造体ですが、<code>typeof</code> 演算子：</span><code>typeof instance === "<strong>function</strong>"</code> に応答します。すべての関数コンストラクターはオブジェクトコンストラクターから派生していますが、これは単に Functions の特別な省略形にすぎません。</li>
  </ul>
 </li>
 <li><strong>構造的ルート</strong>プリミティブ
  <ul>
   <li><strong><a href="/ja/docs/Glossary/Null">null</a></strong><span> : </span><code>typeof instance === "<strong>object</strong>"</code> オブジェクトが継承されていない場合、特別な<a href="/ja/docs/Glossary/Primitive">プリミティブ</a>型 <code>null</code> が示されます。</li>
  </ul>
 </li>
</ul>

<p><code>typeof</code> 演算子は、データ型以外を正しく判定できないので注意してください。オブジェクトから派生した構造的な型を判定しても、常に <code>"object"</code> を受け取ることになるので、<code>typeof</code> を使用する意味がありません。オブジェクトの型を確認するための適切な方法は、{{jsxref("Operators/instanceof", "instanceof")}} キーワードを使用することです。しかし、その場合でも誤った判定があるかもしれません。</p>

<p>ご覧のとおり、すべてのプリミティブ型の意味は、ほとんど同じである undefined と null を除いては明らかです。<strong>undefined</strong> は、まだ存在しない、あるいはもう存在しないものを表現します。<strong>null</strong> は、存在するが中身が空であることを表現したものです。</p>

<h2 id="Primitive_values" name="Primitive_values">プリミティブ値</h2>

<p>オブジェクトを除くすべての型は不変の値 (つまり、変更できない値) として定義されています。例えば文字列は（C 言語とは異なり）不変です。これらの型の値を、<em>プリミティブ値</em>と呼びます。</p>

<h3 id="Boolean_type" name="Boolean_type">Boolean 型</h3>

<p>Boolean は論理的な実体であり <code>true</code> と <code>false</code> の 2 つの値があります。詳しくは <a href="/ja/docs/Glossary/Boolean">Boolean</a> および {{jsxref("Boolean")}} 参照してください。</p>

<h3 id="Null_type" name="Null_type">Null 型</h3>

<p>Null 型は値が <code>null</code> の 1 つしかありません。詳しくは {{jsxref("null")}} および <a href="/ja/docs/Glossary/Null">Null</a> を参照してください。</p>

<h3 id="Undefined_type" name="Undefined_type">Undefined 型</h3>

<p>値を代入していない変数の値は <code>undefined</code> になります。詳しくは {{jsxref("undefined")}} および <a href="/ja/docs/Glossary/Undefined">Undefined</a> を参照してください。</p>

<h3 id="Number_type" name="Number_type">Number 型</h3>

<p>ECMAScript には、<strong>Number</strong> と <strong>BigInt</strong> の 2 つの組み込み数値型があります。（以下を参照）</p>

<p>Number 型は、<a href="https://ja.wikipedia.org/wiki/%E5%80%8D%E7%B2%BE%E5%BA%A6%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0">IEEE 754 での倍精度浮動小数点数</a> ( -(2<sup>53</sup> − 1) から 2<sup>53</sup> − 1) の間の数値) です。浮動小数点数の表現に加えて、3 つの記号的な値 <code>+Infinity</code>, <code>-Infinity</code>, {{jsxref("NaN")}} ("<strong>N</strong>ot a <strong>N</strong>umber") があります。</p>

<p>{{jsxref("Infinity", "±Infinity")}} 内で使用可能な最大値または最小値を確認するには、定数 {{jsxref("Number.MAX_VALUE")}} または {{jsxref("Number.MIN_VALUE")}} を使用できます。</p>

<div class="blockIndicator note">
<p><strong>ECMAScript 2015</strong> からは、{{jsxref("Number.isSafeInteger()")}}, {{jsxref("Number.MAX_SAFE_INTEGER")}}, {{jsxref("Number.MIN_SAFE_INTEGER")}} を使用して、数値が倍精度浮動小数点数の範囲内にあるかどうかを確認することができるようになりました。</p>

<p>この範囲を超えた JavaScript の整数値はもう正確ではなくなり、倍精度浮動小数点の近似値に丸められます。</p>
</div>

<p>Number 型には、2 種類の表現を持つ数値がひとつだけあります。それは <code>0</code> であり、<code>-0</code> および <code>+0</code> で表します。(<code>0</code> は <code>+0</code> の別名です)</p>

<p>実用上、どちらを使用しても影響はほとんどありません。例えば、<code>+0 === -0</code> は <code>true</code> です。ただし、ゼロ除算を行った場合は違いに気づくでしょう。</p>

<pre class="brush: js notranslate">&gt; 42 / +0
Infinity
&gt; 42 / -0
-Infinity
</pre>

<p>多くの場合、数値はその値のみを表しますが、JavaScript には{{jsxref("Operators/Bitwise_Operators", "バイナリー（ビット単位）演算子")}}も用意されています。</p>

<div class="blockIndicator note">
<p><strong>注:</strong> ビット演算子を使用すれば、<a class="external" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B9%E3%82%AF_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)">ビットマスク</a>を用いて、1 つの数値で複数の真偽値を表現することも<em>可能です</em>。しかしながら、JavaScript が（真偽値の配列や名前付きプロパティに真偽値が割り当てられたオブジェクトのような）真偽値の集合を表現する手段を提供しているため、この行いは悪い習慣として考えられます。ビットマスクはコードの可読性、わかりやすさ、保守性を大きく損なってしまいます。</p>
</div>

<p>ローカルストレージの容量的制約への対処や、ビット単位での転送量を考える必要のある極限状態など、非常に特殊なケースにおいてはこうしたテクニックが必要となるでしょう。このテクニックは、あくまでも最適化が必要な場合の最終手段としてのみ考慮すべきです。</p>

<h3 id="BigInt_type" name="BigInt_type">BigInt 型</h3>

<p>{{jsxref("BigInt")}} 型は、任意の精度で整数を表現できる JavaScript の数値プリミティブです。<code>BigInt</code> を使えば、<code>Number</code> で扱える安全な整数の限界を超える、大きな整数を安全に格納して操作することができます。</p>

<p><code>BigInt</code> は、整数の末尾に <code>n</code> を追加するか、コンストラクターを呼び出すことで作成します。</p>

<p>定数 {{jsxref("Number.MAX_SAFE_INTEGER")}} を使用することで、<code>Number</code> でインクリメントできる最も安全な値を得ることができます。<code>BigInt</code> の導入により、{{jsxref("Number.MAX_SAFE_INTEGER")}} を超える数値での操作が可能になりました。</p>

<p>この例は、{{jsxref("Number.MAX_SAFE_INTEGER")}} をインクリメントすると期待される結果が返ってくることを示しています。</p>

<pre class="brush: js notranslate">&gt; const x = 2n ** 53n;
9007199254740992n
&gt; const y = x + 1n;
9007199254740993n
</pre>

<p><code>BigInt</code> は、<code>Number</code> と同じように <code>+</code>, <code>*</code>, <code>-</code>, <code>**</code>, <code>%</code> 演算子を使用できます。<code>BigInt</code> は <code>Number</code> と厳密に等しいわけではありませんが、ほとんど同じです。</p>

<p><code>BigInt</code> は、<code>if</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>Boolean</code>, <code>!</code> などで<code>真偽値</code>に変換される場合、Number と同じように動作します。</p>

<p><code>BigInt</code> は、<code>Number</code> と同時に使用することはできません。代わりに、{{jsxref("TypeError")}} が投げられます。</p>

<h3 id="String_type" name="String_type">String 型</h3>

<p>JavaScript の {{jsxref("String")}} 型は、テキストデータを表すために使用します。これは、16 ビット符号なし整数値の「要素」の集合体で、文字列内の各要素は文字列内の位置を占めます。要素の数が文字列の長さになり、最初の要素がインデックス <code>0</code>、次の要素がインデックス <code>1</code> となっていきます。</p>

<p>いくつかのプログラミング言語（C 言語など）とは異なり、JavaScript の文字列は不変です。これは、一度作成した文字列を変更することができないことを意味します。</p>

<p>しかしながら、原文の文字列に対する操作に基づいて別の文字列を作成することは可能です。例えば、以下のようになります。</p>

<ul>
 <li>個別に文字を抜き出す、または {{jsxref("String.substr()")}} を用いて、原文の部分文字列を切り出す</li>
 <li>連結演算子 (<code>+</code>) または {{jsxref("String.concat()")}} を用いて、2 つの文字列を連結する</li>
</ul>

<h4 id="「文字列っぽい」コードに注意！">「文字列っぽい」コードに注意！</h4>

<p>複雑なデータを表現するために文字列を使用したい思うこともあるでしょう。これには短期的なメリットがあります。</p>

<ul>
 <li>文字列は連結を使用して複雑な文字列を簡単に作成できます。</li>
 <li>文字列は簡単にデバッグできます。（出力される情報は常に文字列に含まれているものです）</li>
 <li>文字列は多くの API（<a href="/ja/docs/Web/API/HTMLInputElement">入力フィールド</a>、<a href="/ja/docs/Web/API/Window/localStorage">ローカルストレージ</a>の値、<a href="/ja/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> の <code>responseText</code> など）において共通分母であり、文字列だけで作業したいという誘惑に駆られることがあります。</li>
</ul>

<p>ルールさえあれば、どのようなデータ構造でも文字列で表現することが可能ですが、これは良いアイデアとは言えません。例えば、区切り文字を使用することでリストを模倣することができますが（JavaScript の配列の方が適しています）、残念なことに区切り文字がリストの要素となってしまった場合、リストが壊れてしまいます。エスケープした文字を使用することでこの問題に対処することは可能ですが、そのルールをすべてに用意する必要がある上、不必要なメンテナンスの負担を生み出します。</p>

<p>文字列はテキストデータには向いていますが、複雑なデータを表す場合は文字列を<em>解析</em>し、適切な抽象化を用いる必要があります。</p>

<h3 id="Symbol_type" name="Symbol_type">Symbol 型</h3>

<p>シンボルは<strong>一意</strong>で<strong>不変</strong>のプリミティブ値であり、オブジェクトのプロパティのキーとして使用することができます。いくつかのプログラミング言語では、"atoms" と呼ばれています。</p>

<p>詳しくは、<a href="/ja/docs/Glossary/Symbol">Symbol</a> および{{jsxref("Symbol" ,"シンボル")}}ラッパーオブジェクトを参照してください。</p>

<h2 id="Objects" name="Objects">Objects</h2>

<p>コンピューター科学において、オブジェクトは<a href="/ja/docs/Glossary/Identifier">識別子</a>によって参照可能なメモリー内の値です。</p>

<h3 id="Properties" name="Properties">プロパティ</h3>

<p>JavaScript では、オブジェクトはプロパティの集合として見ることができます。<a href="/ja/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Object_literals">オブジェクトリテラル構文</a>は、プロパティの初期化・追加・削除を行い、String 値または Symbol 値のいずれかの<em>キー</em>値を使用して識別します。プロパティの値は、他のオブジェクトを含むあらゆる型の値にすることができ、複雑なデータ構造を構築できます。</p>

<p>オブジェクトには、<em>データ</em>プロパティと<em>アクセサ</em>プロパティという特定の属性を持つ 2 種類のプロパティがあります。</p>

<div class="blockIndicator note">
<p><strong>注: </strong>各プロパティに対応する<em>属性</em>は JavaScript エンジンによって内部的に使用されるので、直接アクセスすることはできません。そのため、属性は 1 つではなく 2 つの角括弧で表示されています。</p>

<p>詳しくは {{jsxref("Object.defineProperty()")}} を参照してください。</p>
</div>

<h4 id="Data_property" name="Data_property">データプロパティ</h4>

<p>キーと値を関連づけて、以下の属性を持ちます。</p>

<table class="standard-table">
 <caption>データプロパティの属性</caption>
 <thead>
  <tr>
   <th scope="col">属性</th>
   <th scope="col">型</th>
   <th scope="col">説明</th>
   <th scope="col">既定値</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>[[Value]]</td>
   <td>JavaScript の任意の型</td>
   <td>プロパティにアクセスすると取り出される値です。</td>
   <td><code>undefined</code></td>
  </tr>
  <tr>
   <td>[[Writable]]</td>
   <td>Boolean</td>
   <td><code>false</code> であれば、プロパティの [[Value]] は変更できません。</td>
   <td><code>false</code></td>
  </tr>
  <tr>
   <td>[[Enumerable]]</td>
   <td>Boolean</td>
   <td>
    <p>If <code>true</code> であれば、プロパティは <a href="/ja/docs/Web/JavaScript/Reference/Statements/for...in">for...in</a> ループで列挙されます。<br>
     <a href="/ja/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">プロパティの列挙可能性と所有権</a>も参照してください。</p>
   </td>
   <td><code>false</code></td>
  </tr>
  <tr>
   <td>[[Configurable]]</td>
   <td>Boolean</td>
   <td><code>false</code> であれば、プロパティは削除できません。また、[[Value]] および [[Writable]] 以外の属性を変更できません。</td>
   <td><code>false</code></td>
  </tr>
 </tbody>
</table>

<table class="standard-table">
 <caption>廃止された属性 (ECMAScript 3 の属性で、ECMAScript 5 で改名されました)</caption>
 <thead>
  <tr>
   <th scope="col">属性</th>
   <th scope="col">型</th>
   <th scope="col">説明</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Read-only</td>
   <td>Boolean</td>
   <td>ES5 の [[Writable]] 属性の状態を反転したもの。</td>
  </tr>
  <tr>
   <td>DontEnum</td>
   <td>Boolean</td>
   <td>ES5 の [[Enumerable]] 属性の状態を反転したもの。</td>
  </tr>
  <tr>
   <td>DontDelete</td>
   <td>Boolean</td>
   <td>ES5 の [[Configurable]] 属性の状態を反転したもの。</td>
  </tr>
 </tbody>
</table>

<h4 id="Accessor_property" name="Accessor_property">アクセサプロパティ</h4>

<p>値を取り出しまたは保存するための 1 つまたは 2 つのアクセサ関数（<code>get</code> および <code>set</code>）とキーを関連づけており、以下の属性を持ちます。</p>

<table class="standard-table">
 <caption>アクセサプロパティの属性</caption>
 <thead>
  <tr>
   <th scope="col">属性</th>
   <th scope="col">型</th>
   <th scope="col">説明</th>
   <th scope="col">既定値</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>[[Get]]</td>
   <td>Function オブジェクトまたは <code>undefined</code></td>
   <td>値に対して get アクセスが実行されると、関数が引数なしで呼び出されてプロパティの値を取り出します。<br>
    <a href="/ja/docs/Web/JavaScript/Reference/Operators/get"><code>get</code></a> も参照してください。</td>
   <td><code>undefined</code></td>
  </tr>
  <tr>
   <td>[[Set]]</td>
   <td>Function オブジェクトまたは <code>undefined</code></td>
   <td>指定したプロパティを変更しようとしたときに、代入する値を引数に含めて関数が呼び出されます。<br>
    <a href="/ja/docs/Web/JavaScript/Reference/Operators/set"><code>set</code></a> も参照してください。</td>
   <td><code>undefined</code></td>
  </tr>
  <tr>
   <td>[[Enumerable]]</td>
   <td>Boolean</td>
   <td><code>true</code> であれば、プロパティは <a href="/ja/docs/Web/JavaScript/Reference/Statements/for...in">for...in</a> ループで列挙されます。</td>
   <td><code>false</code></td>
  </tr>
  <tr>
   <td>[[Configurable]]</td>
   <td>Boolean</td>
   <td><code>false</code> であれば、プロパティの削除やデータプロパティの変更はできません。</td>
   <td><code>false</code></td>
  </tr>
 </tbody>
</table>

<h3 id="Normal_objects_and_functions" name="Normal_objects_and_functions">「通常の」オブジェクトおよび関数</h3>

<p>JavaScript オブジェクトは<em>キー</em>と<em>値</em>を所持しています。キーは文字列（または{{jsxref("Symbol", "シンボル")}}）ですが、<em>値</em>はなんでもかまいません。これにより、オブジェクトは <a class="external" href="https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB">HashMap</a> に自然に適合します。</p>

<p>関数は<em>呼び出し可能</em>という付加機能を持つ、通常のオブジェクトです。</p>

<h3 id="Dates" name="Dates">日付</h3>

<p>日付を表現する場合は、JavaScript に組み込まれた <a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code> ユーティリティ</a> を使用するのが最適です。</p>

<h3 id="Indexed_collections_Arrays_and_typed_Arrays" name="Indexed_collections_Arrays_and_typed_Arrays">インデックス付きコレクション: 配列および型付き配列</h3>

<p><a href="/ja/docs/JavaScript/Reference/Global_Objects/Array" title="Array">配列</a>は、整数値をキーにするプロパティと <code>length</code> プロパティの間に特殊な関係の存在する、標準オブジェクトです。</p>

<p>さらに、配列は <code>Array.prototype</code> を継承しており、配列を操作するための便利なメソッドを提供しています。例えば、<code><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></code>（配列中の値の検索）や <code><a href="/ja/docs/JavaScript/Reference/Global_Objects/Array/push">push</a></code>（配列への要素の追加）などです。これにより、配列はリストや集合を表現するのに最適な候補となります。</p>

<p><a href="/ja/docs/Web/JavaScript/Typed_arrays">型付き配列</a>は、ECMAScript 2015 で JavaScript に新しく追加されたもので、基礎となるバイナリーデータバッファの配列状のビューを提示します。次の表は、同等の C データ型を見つけるのに役立ちます。</p>

<table class="standard-table">
 <thead>
  <tr>
   <th class="header" scope="col">型</th>
   <th class="header" scope="col">値の範囲</th>
   <th class="header" scope="col">サイズ (バイト数)</th>
   <th class="header" scope="col">説明</th>
   <th class="header" scope="col">Web IDL 型</th>
   <th class="header" scope="col">同等の C 型</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("Int8Array")}}</td>
   <td><code>-128</code> から <code>127</code></td>
   <td>1</td>
   <td>8 ビット 2 の補数方式の符号付き整数値</td>
   <td><code>byte</code></td>
   <td><code>int8_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Uint8Array")}}</td>
   <td><code>0</code> から <code>255</code></td>
   <td>1</td>
   <td>8 ビット 符号なし整数値</td>
   <td><code>octet</code></td>
   <td><code>uint8_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Uint8ClampedArray")}}</td>
   <td><code>0</code> から <code>255</code></td>
   <td>1</td>
   <td>8 ビット 符号なし整数値 (切り詰め)</td>
   <td><code>octet</code></td>
   <td><code>uint8_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Int16Array")}}</td>
   <td><code>-32768</code> から <code>32767</code></td>
   <td>2</td>
   <td>16 ビット 2 の補数方式の符号付き整数値</td>
   <td><code>short</code></td>
   <td><code>int16_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Uint16Array")}}</td>
   <td><code>0</code> から <code>65535</code></td>
   <td>2</td>
   <td>16 ビット 符号なし整数値</td>
   <td><code>unsigned short</code></td>
   <td><code>uint16_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Int32Array")}}</td>
   <td><code>-2147483648</code> から <code>2147483647</code></td>
   <td>4</td>
   <td>32 ビット 2 の補数方式の符号付き整数値</td>
   <td><code>long</code></td>
   <td><code>int32_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Uint32Array")}}</td>
   <td><code>0</code> から <code>4294967295</code></td>
   <td>4</td>
   <td>32 ビット 符号なし整数値</td>
   <td><code>unsigned long</code></td>
   <td><code>uint32_t</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Float32Array")}}</td>
   <td><code>1.2</code><span>×</span><code>10<sup>-38</sup></code> から <code>3.4</code><span>×</span><code>10<sup>38</sup></code></td>
   <td>4</td>
   <td>32 ビット IEEE 浮動小数点数 (7 桁の有効数字 例：<code>1.1234567</code>)</td>
   <td><code>unrestricted float</code></td>
   <td><code>float</code></td>
  </tr>
  <tr>
   <td>{{jsxref("Float64Array")}}</td>
   <td><code>5.0</code><span>×</span><code>10<sup>-324</sup></code> から <code>1.8</code><span>×</span><code>10<sup>308</sup></code></td>
   <td>8</td>
   <td>64 ビット IEEE 浮動小数点数 (16 桁の有効数字 例：<code>1.123...15</code>)</td>
   <td><code>unrestricted double</code></td>
   <td><code>double</code></td>
  </tr>
  <tr>
   <td>{{jsxref("BigInt64Array")}}</td>
   <td><code>-2<sup>63</sup></code> から <code>2<sup>63</sup>-1</code></td>
   <td>8</td>
   <td>64 ビット 2 の補数方式の符号付き整数値</td>
   <td><code>bigint</code></td>
   <td><code>int64_t (signed long long)</code></td>
  </tr>
  <tr>
   <td>{{jsxref("BigUint64Array")}}</td>
   <td><code>0</code> から <code>2<sup>64</sup>-1</code></td>
   <td>8</td>
   <td>64 ビット 符号なし整数値</td>
   <td><code>bigint</code></td>
   <td><code>uint64_t (unsigned long long)</code></td>
  </tr>
 </tbody>
</table>

<h3 id="Keyed_collections_Maps_Sets_WeakMaps_WeakSets" name="Keyed_collections_Maps_Sets_WeakMaps_WeakSets">キー付きコレクション: Map, Set, WeakMap, WeakSet</h3>

<p>ECMAScript 2015 で導入されたこれらのデータ構造は、オブジェクト参照をキーとしています。{{jsxref("Set")}} と {{jsxref("WeakSet")}} はオブジェクトの集合を表し、{{jsxref("Map")}} と {{jsxref("WeakMap")}} はオブジェクトに値を関連付けます。</p>

<p><code>Map</code> と <code>WeakMap</code> の違いは、前者ではオブジェクトキーを列挙できることです。これにより、後者の場合にガベージコレクションの最適化が可能になります。</p>

<p>純粋な ECMAScript 5 で <code>Map</code> と <code>Set</code> を実装することもできますが、オブジェクトを比較することはできないので（例えば <code>&lt;</code> 未満の意味で）、検索性能が必然的に線形になります。これらのネイティブ実装（<code>WeakMap</code> を含む）は、一定時間に対してほぼ対数的な検索性能を持つことができます。</p>

<p>通常、DOM ノードにデータをバインドするには、オブジェクトに直接プロパティを設定するか、<code>data-*</code> 属性を使用します。これらの手法は同じコンテクストで実行されるあらゆるスクリプトからデータの利用が可能であるため、不都合な面を持ち合わせていました。<code>Map</code> や <code>WeakMap</code> を使うと、オブジェクトへの<em>プライベート</em>なデータバインドを簡単に行うことができます。</p>

<h3 id="Structured_data_JSON" name="Structured_data_JSON">構造化データ: JSON</h3>

<p>JSON (<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation) は JavaScript から派生した汎用データ構造をもつ軽量なデータ交換フォーマットであり、多くのプログラミング言語で使用されています。</p>

<p>詳しくは <a href="/ja/docs/Glossary/JSON">JSON</a> および {{jsxref("JSON")}} を参照してください。</p>

<h3 id="More_objects_in_the_standard_library" name="More_objects_in_the_standard_library">標準ライブラリに含まれる他のオブジェクト</h3>

<p>JavaScript には組み込みオブジェクトの標準ライブラリがあります。</p>

<p>オブジェクトの詳細については、<a href="/ja/docs/Web/JavaScript/Reference/Global_Objects">リファレンス</a>を参照してください。</p>

<h2 id="Determining_types_using_the_typeof_operator" name="Determining_types_using_the_typeof_operator"><code>typeof</code> 演算子を使用して型を検出する</h2>

<p><code>typeof</code> 演算子は、変数の型を知るのに役立ちます。</p>

<p>詳細および使用例については、<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/typeof">リファレンスページ</a>を参照してください。</p>

<h2 id="Specifications" name="Specifications">仕様</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">仕様書</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-ecmascript-data-types-and-values', 'ECMAScript Data Types and Values')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="See_also" name="See_also">関連情報</h2>

<ul>
 <li><a class="link-https" href="https://github.com/nzakas/computer-science-in-javascript/">Nicholas Zakas による、JavaScript における一般的なデータ構造とアルゴリズムのまとめ</a></li>
 <li><a href="https://github.com/monmohan/DataStructures_In_Javascript">Search Tre(i)es implemented in JavaScript</a></li>
</ul>
