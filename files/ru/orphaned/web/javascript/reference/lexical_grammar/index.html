---
title: Лексический синтаксис
slug: orphaned/Web/JavaScript/Reference/Lexical_grammar
tags:
  - JavaScript
  - Keyword
  - Literal
  - ключевые слова
  - литералы
translation_of: Web/JavaScript/Reference/Lexical_grammar
original_slug: Web/JavaScript/Reference/Lexical_grammar
---
<div>{{JsSidebar("More")}}</div>

<div>Этот раздел описывает синтаксис JavaScript. Исходный код ECMAScript скриптов сканируется слева направо и преобразуется в последовательность найденных элементов в токены, управляющие символы, окончания строк, комментарии или пробелы.<br>
ECMAScript также определяет ключевые слова и литералы и имеет указания для автоматической вставки точек с запятой к концу инструкции.</div>

<h2 id="Спецсимволы">Спецсимволы</h2>

<p>Спецсимволы не имеют визуального представления, однако используются для управления интерпретацией текста.</p>

<table class="standard-table">
 <caption>Юникодные форматирующие спецсимволы</caption>
 <tbody>
  <tr>
   <th>Code point</th>
   <th>Name</th>
   <th>Abbreviation</th>
   <th>Description</th>
  </tr>
  <tr>
   <td><code>U+200C</code></td>
   <td>Zero width non-joiner</td>
   <td>&lt;ZWNJ&gt;</td>
   <td>Размещается между символами во избежание их соединений в лигатуры для некоторых языков (<a href="http://en.wikipedia.org/wiki/Zero-width_non-joiner">Wikipedia</a>)</td>
  </tr>
  <tr>
   <td><code>U+200D</code></td>
   <td>Zero width joiner</td>
   <td>&lt;ZWJ&gt;</td>
   <td>Размещается между символами, которые не могли бы нормально объединиться для того, чтобы символы отрисовывались, используя их соединительную форму в некоторых языках (<a href="http://en.wikipedia.org/wiki/Zero-width_joiner">Wikipedia</a>)</td>
  </tr>
  <tr>
   <td><code>U+FEFF</code></td>
   <td>Byte order mark</td>
   <td>&lt;BOM&gt;</td>
   <td>Используется вначале скрипта для того, чтобы пометить Юникод и порядок байтов (<a href="http://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia</a>)</td>
  </tr>
 </tbody>
</table>

<h2 id="Пробелы">Пробелы</h2>

<p>Пробельные символы улучшают читабельность исходного текста и разделяет токены друг от друга. Пробельные символы обычно не обязательны для функционирования кода. <a href="http://en.wikipedia.org/wiki/Minification_%28programming%29">Утилиты для уменьшения объёма кода</a> часто удаляют пробельные символы, чтобы уменьшить объем кода.</p>

<table class="standard-table">
 <caption>Таблица пробельных символов</caption>
 <tbody>
  <tr>
   <th>Code point</th>
   <th>Name</th>
   <th>Abbreviation</th>
   <th>Description</th>
   <th>Escape sequence</th>
  </tr>
  <tr>
   <td>U+0009</td>
   <td>Character tabulation</td>
   <td>&lt;HT&gt;</td>
   <td>Горизонтальная табуляция</td>
   <td>\t</td>
  </tr>
  <tr>
   <td>U+000B</td>
   <td>Line tabulation</td>
   <td>&lt;VT&gt;</td>
   <td>Вертикальная табуляция</td>
   <td>\v</td>
  </tr>
  <tr>
   <td>U+000C</td>
   <td>Form feed</td>
   <td>&lt;FF&gt;</td>
   <td>Символ контроля разрыва страницы (<a href="http://en.wikipedia.org/wiki/Page_break#Form_feed">Wikipedia</a>)</td>
   <td>\f</td>
  </tr>
  <tr>
   <td>U+0020</td>
   <td>Space</td>
   <td>&lt;SP&gt;</td>
   <td>Обычный пробел</td>
   <td></td>
  </tr>
  <tr>
   <td>U+00A0</td>
   <td>No-break space</td>
   <td>&lt;NBSP&gt;</td>
   <td>
    <p>Обычный пробел без точки, на которой может произойти разрыв страницы</p>
   </td>
   <td></td>
  </tr>
  <tr>
   <td>Others</td>
   <td>Other Unicode space characters</td>
   <td>&lt;USP&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Space_%28punctuation%29#Spaces_in_Unicode">Другие символы в Юникоде на Википедии</a></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Окончание_строк">Окончание строк</h2>

<p>В дополнение к пробельным символам, символы окончания строк тоже используются для читабельности исходного кода. Однако, в некоторых случаях, символы окончания строк могут влиять на выполнение JavaScript кода, т.к. есть некоторые места, где они запрещены.</p>

<p>Окончания строк также затрагивают процесс <a href="#Automatic_semicolon_insertion">автоматического проставления точки с запятой</a>. Также окончания строк попадают под условия <a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">регулярных выражений</a> при поиске <strong>\s</strong> класса.</p>

<p>В ECMAScript, в качестве окончания строк можно использовать только ниже перечисленные Юникод символы. Другие символы окончания строк будут интерпретированы, как пробельные символы (например, Next Line, NEL, U+0085 будут интерпретироваться, как пробельные символы).</p>

<table class="standard-table">
 <caption>Символы окончания строк</caption>
 <tbody>
  <tr>
   <th>Code point</th>
   <th>Name</th>
   <th>Abbreviation</th>
   <th>Description</th>
   <th>Escape sequence</th>
  </tr>
  <tr>
   <td>U+000A</td>
   <td>Line Feed</td>
   <td>&lt;LF&gt;</td>
   <td>Новая строка в UNIX системах.</td>
   <td>\n</td>
  </tr>
  <tr>
   <td>U+000D</td>
   <td>Carriage Return</td>
   <td>&lt;CR&gt;</td>
   <td>Новая строка в Commodore и ранних Mac systems.</td>
   <td>\r</td>
  </tr>
  <tr>
   <td>U+2028</td>
   <td>Line Separator</td>
   <td>&lt;LS&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Newline">Wikipedia</a></td>
   <td></td>
  </tr>
  <tr>
   <td>U+2029</td>
   <td>Paragraph Separator</td>
   <td>&lt;PS&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Newline">Wikipedia</a></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Комментарии">Комментарии</h2>

<p>Комментарии используются для добавления подсказок, заметок, предложений или предупреждений. Они могут упростить чтение и понимание кода. Также они могут быть использованы для предотвращения выполнения кода (этот приём практикуется при отладке кода).</p>

<p>В JavaScript есть несколько способов указать комментарии в коде.</p>

<p>Первый способ <code>//</code> комментарий; в этом случае весь текст в строке после двойного слеша будет комментарием, например:</p>

<pre class="brush: js notranslate">function comment() {
  // Это комментарий в строке
  console.log("Hello world!");
}
comment();
</pre>

<p>Второй способ - это <code>/* */</code>, такой способ более гибок, чем первый.</p>

<p>Например, вы можете использовать его в одной строке:</p>

<pre class="brush: js notranslate">function comment() {
  /* Это однострочный комментарий */
  console.log("Hello world!");
}
comment();</pre>

<p>Либо вы можете сделать многострочный комментарий, как показано здесь:</p>

<pre class="brush: js notranslate">function comment() {
  /* Этот комментарий располагается на нескольких линиях.
     Обратите внимание, что вам не нужно обрывать комментарий, пока вы его не закончите*/
  console.log("Hello world!");
}
comment(); </pre>

<p>Также, если пожелаете, то вы можете использовать такое комментирование посреди строки кода. Хотя это может ухудшить читабельность кода:</p>

<pre class="brush: js notranslate">function comment(x) {
  console.log("Hello " + x /* вставьте значение x */ + " !");
}
comment("world");</pre>

<p>Чтобы отключить выполнение кода, просто оберните код в комментарий, как здесь:</p>

<pre class="brush: js notranslate">function comment() {
  /* console.log("Hello world!"); */
}
comment();</pre>

<p>В этом случае <code>console.log()</code> никогда не выполнится, пока он внутри комментария. Таким способом можно отключить любое количество строк кода.</p>

<h2 id="Шебанг_комментарии">Шебанг комментарии</h2>

<p>Третий специализированный синтаксис комментариев, <strong>шебанг комментарий</strong>, в процессе стандартизации в ECMAScript (смотреть <a href="https://github.com/tc39/proposal-hashbang">Hashbang Grammar proposal</a>).</p>

<p>Шебанг комментарий ведёт себя точно также как и однострочный (<code>//</code>) комментарий. Вместо этого, он начинается с <code>#!</code> и <strong>действителен только в самом начале скрипта или модуля</strong>. Обратите внимание, что никакие пробелы не разрешены перед <code>#!</code>. Комментарий состоит из всех символов после <code>#!</code> до конца первой строки; только такой комментарий разрешён.</p>

<p>Шебанг комментарий определяет путь к  JavaScript интерпретатору, скрипт которого вы хотите выполнить. Пример, как это работает:</p>

<pre class="brush: js notranslate">#!/usr/bin/env node

console.log("Hello world");
</pre>

<div class="blockIndicator note">
<p><strong>Note</strong>: Hashbang comments in JavaScript mimic <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebangs in Unix</a> used to run files with proper interpreter.</p>
</div>

<div class="blockIndicator warning">
<p>Although <a href="https://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> before hashbang comment will work in a browser it is not advised to use BOM in a script with hasbang. BOM will not work when you try to run the script in Unix/Linux. So use UTF-8 without BOM if you want to run scripts directly from shell.</p>
</div>

<p>Для определения JavaScript интерпретатора используйте только <code>#!</code> . В любых других случаях используйте <code>//</code> (или многострочный комментарий).</p>

<h2 id="Ключевые_слова"><a id="Keywords" name="Keywords"></a>Ключевые слова</h2>

<h3 id="Зарезервированные_ключевые_слова_в_ECMAScript_2015">Зарезервированные ключевые слова в ECMAScript 2015</h3>

<div class="threecolumns">
<ul>
 <li>{{jsxref("Statements/break", "break")}}</li>
 <li>{{jsxref("Statements/switch", "case")}}</li>
 <li><code>class</code></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"><code>catch</code></a></li>
 <li>{{jsxref("Statements/const", "const")}}</li>
 <li>{{jsxref("Statements/continue", "continue")}}</li>
 <li>{{jsxref("Statements/debugger", "debugger")}}</li>
 <li>{{jsxref("Statements/switch", "default")}}</li>
 <li>{{jsxref("Operators/delete", "delete")}}</li>
 <li>{{jsxref("Statements/while", "do")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>else</code></a></li>
 <li>{{jsxref("Statements/export", "export")}}</li>
 <li><code>extends</code></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"><code>finally</code></a></li>
 <li>{{jsxref("Statements/for", "for")}}</li>
 <li>{{jsxref("Statements/function", "function")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>if</code></a></li>
 <li>{{jsxref("Statements/import", "import")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code>in</code></a></li>
 <li>{{jsxref("Operators/instanceof", "instanceof")}}</li>
 <li>{{jsxref("Statements/let", "let")}}</li>
 <li>{{jsxref("Operators/new", "new")}}</li>
 <li>{{jsxref("Statements/return", "return")}}</li>
 <li>{{jsxref("Operators/super", "super")}}</li>
 <li>{{jsxref("Statements/switch", "switch")}}</li>
 <li>{{jsxref("Operators/this", "this")}}</li>
 <li>{{jsxref("Statements/throw", "throw")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"><code>try</code></a></li>
 <li>{{jsxref("Operators/typeof", "typeof")}}</li>
 <li>{{jsxref("Statements/var", "var")}}</li>
 <li>{{jsxref("Operators/void", "void")}}</li>
 <li>{{jsxref("Statements/while", "while")}}</li>
 <li>{{jsxref("Statements/with", "with")}}</li>
 <li><code>yield</code></li>
</ul>
</div>

<h3 id="Ключевые_слова_зарезервированные_на_будущее">Ключевые слова, зарезервированные на будущее</h3>

<p>Следующие ключевые слова зарезервированы на будущее ECMAScript спецификацией. За ними сейчас не стоит никакой функциональности, но она может появиться в будущих версиях, поэтому эти ключевые слова не могут быть использованы, как идентификаторы. Эти ключевые слова не могут быть использованы даже в strict или non-strict режимах.</p>

<ul>
 <li><code>enum</code></li>
 <li><code>await</code></li>
</ul>

<p>Следующие ключевые слова зарезервированы для кода, который выполняется в strict режиме:</p>

<div class="threecolumns">
<ul>
 <li><code>implements</code></li>
 <li><code>package</code></li>
 <li><code>protected</code></li>
 <li><code>static</code></li>
 <li><code>interface</code></li>
 <li><code>private</code></li>
 <li><code>public</code></li>
</ul>
</div>

<h3 id="Зарезервированные_ключевые_слова_в_более_старых_версиях">Зарезервированные ключевые слова в более старых версиях</h3>

<p>Перечисленные ниже ключевые слова зарезервированы для старых версий ECMAScript спецификаций (ECMAScript от 1 по 3).</p>

<div class="threecolumns">
<ul>
 <li><code>abstract</code></li>
 <li><code>boolean</code></li>
 <li><code>byte</code></li>
 <li><code>char</code></li>
 <li><code>double</code></li>
 <li><code>final</code></li>
 <li><code>float</code></li>
 <li><code>goto</code></li>
 <li><code>int</code></li>
 <li><code>long</code></li>
 <li><code>native</code></li>
 <li><code>short</code></li>
 <li><code>synchronized</code></li>
 <li><code>transient</code></li>
 <li><code>volatile</code></li>
</ul>
</div>

<p>К тому же, литералы <code>null</code>, <code>true</code>, и <code>false</code> зарезервированы в ECMAScript для их обычной функциональности.</p>

<h3 id="Reserved_word_usage" name="Reserved_word_usage"></h3>

<h3 id="Reserved_word_usage" name="Reserved_word_usage">Использование зарезервированных слов</h3>

<p>Зарезервированные слова действительно применяются только к идентификаторам<strong> (vs. IdentifierNames)</strong>. Как описано в <a href="http://es5.github.com/#A.1">es5.github.com/#A.1</a>, это все имена IdentifierNames, которые не исключают зарезервированных слов.</p>

<pre class="brush: js notranslate">a.import
a["import"]
a = { import: "test" }.
</pre>

<p>С другой стороны, следующее выражение неправильно, т.к. Идентификатор <code>IdentifierName</code> не содержит зарезервированных слов. Идентификаторы используются для <code>FunctionDeclaration, FunctionExpression, VariableDeclaration</code> и т.п., в то время, как <code>IdentifierNames</code> используются для <code> MemberExpression, CallExpression</code> и т.п.</p>

<pre class="brush: js notranslate">function import() {} // неправильно.</pre>

<h2 id="Литералы">Литералы</h2>

<h3 id="Литерал_Null">Литерал Null</h3>

<p>Подробнее о <code>{{jsxref('Global_Objects/null','null')}}null</code>.</p>

<pre class="brush: js notranslate">null</pre>

<h3 id="Литерал_Boolean">Литерал Boolean</h3>

<p>Подробнее о <code>{{jsxref('Global_Objects/Boolean','Boolean')}}</code>.</p>

<pre class="brush: js notranslate">true
false</pre>

<h3 id="Литералы_чисел">Литералы чисел</h3>

<h4 id="Decimal_десятичные_числа">Decimal (десятичные числа)</h4>

<pre class="brush: js notranslate">1234567890
42

// Будьте осторожны с использованием нуля вначале числа:

0888 // 888 распознается, как десятичное число
0777 // распознается, как восьмеричное число, 511 - как десятичное число
</pre>

<p>Имейте в виду, что литералы десятичных чисел могут начинаться с нуля (0), за которым следует другое десятичное число, но в случае, если число начинается с нуля и за ним идёт цифра меньше 8, то число будет распознано как восьмеричное. This won't throw in JavaScript, see {{bug(957513)}}. See also the page about <code>{{jsxref('Global_Objects/parseInt','parseInt()','Octal_interpretations_with_no_radix')}}</code>.</p>

<h4 id="Binary_двоичные_числа">Binary (двоичные числа)</h4>

<p>Синтаксис двоичных чисел состоит из цифры ноль, за которой следует маленькая или большая латинская буква "B" (0b или 0B). Этот синтаксис новый и появился только в ECMAScript 2015, пожалуйста посмотрите таблицу совместимости с браузерами. Это может производить ошибку <code>{{jsxref('Global_Objects/SyntaxError','SyntaxError')}}</code>: "Missing binary digits after 0b", Если цифры не 0 или 1.</p>

<pre class="brush: js notranslate">var FLT_SIGNBIT  = 0b10000000000000000000000000000000; // 2147483648
var FLT_EXPONENT = 0b01111111100000000000000000000000; // 2139095040
var FLT_MANTISSA = 0B00000000011111111111111111111111; // 8388607</pre>

<h4 id="Octal_восьмеричные_числа">Octal (восьмеричные числа)</h4>

<p>Восьмеричный числовой синтаксис, который использует 0 с последующей, в нижнем или верхнем регистре, латинскую букву "О" (<code>0o</code> или <code>0O)</code>. Этот синтаксис появился в ECMAScript 2015, пожалуйста, посмотрите таблицу совместимости с браузерами. Это может производить ошибку <code>SyntaxError</code>: "Missing octal digits after 0o", если цифры не между 0 и 7.</p>

<pre class="brush: js notranslate">var n = 0O755; // 493
var m = 0o644; // 420

// Так же возможно с лидирующими нулями (см. заметку о десятичных дробях выше)
0755
0644
</pre>

<h4 id="Hexadecimal_шестнадцатеричные_числа">Hexadecimal (шестнадцатеричные числа)</h4>

<p>Шестнадцатеричный числовой синтаксис, который использует 0 с последующей, в нижнем или верхнем регистре, латинскую букву "X" (<code>0x</code> или <code>0X)</code>. Если числа после 0x вне диапазона (0123456789ABCDEF), то может последовать за этим {{jsxref("SyntaxError")}}: "Identifier starts immediately after numeric literal".</p>

<pre class="brush: js notranslate">0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
</pre>

<h3 id="Литерал_Object_Объект">Литерал Object (Объект)</h3>

<p>Смотрите также {{jsxref("Object")}} и {{jsxref('Operators/Object_initializer','Object initializer')}} для получения более подробной информации.</p>

<pre class="brush: js notranslate">var o = { a: "foo", b: "bar", c: 42 };

// сокращённая нотация. Появилась в ES2015
var a = "foo", b = "bar", c = 42;
var o = {a, b, c};
// вместо
var o = { a: a, b: b, c: c };
</pre>

<h3 id="Литерал_Array_Массив">Литерал Array (Массив)</h3>

<p>Смотрите также {{jsxref("Array")}} для получения более подробной информации.</p>

<pre class="brush: js notranslate">[1954, 1974, 1990, 2014]</pre>

<h3 id="Литерал_String_Строка">Литерал String (Строка)</h3>

<pre class="brush: js notranslate">'foo'
"bar"</pre>

<h4 id="Экранирование_шестнадцатеричной_последовательности">Экранирование шестнадцатеричной последовательности</h4>

<pre class="brush: js notranslate">'\xA9' // "©"
</pre>

<h4 id="Экранирование_Юникод_символов">Экранирование Юникод символов</h4>

<p>Для экранирования Юникод символов обязательно нужно указать по крайней мере 4 символа после \u.</p>

<pre class="brush: js notranslate">'\u00A9' // "©"</pre>

<h4 id="Unicode_code_point_escapes">Unicode code point escapes</h4>

<p>Новое в ECMAScript 2015. With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to <code>0x10FFFF</code>. With simple Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same.</p>

<p>See also {{jsxref("String.fromCodePoint()")}} or {{jsxref("String.prototype.codePointAt()")}}.</p>

<pre class="brush: js notranslate">'\u{2F804}'

// the same with simple Unicode escapes
'\uD87E\uDC04'</pre>

<h3 id="Литерал_Регулярного_выражения">Литерал Регулярного выражения</h3>

<p>Смотрите также <code>{{jsxref('Global_Objects/RegExp','RegExp')}}</code> для получения более подробной информации.</p>

<pre class="brush: js notranslate">/ab+c/g

// An "empty" regular expression literal
// The empty non-capturing group is necessary
// to avoid ambiguity with single-line comments.
/(?:)/</pre>

<h3 id="Литерал_Шаблона">Литерал Шаблона</h3>

<p>Смотрите также {{jsxref('template_strings','template strings')}} для получения более подробной информации.</p>

<pre class="brush: js notranslate">`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`</pre>

<h2 id="Автоматическая_вставка_точки_с_запятой">Автоматическая вставка "точки с запятой"</h2>

<p>Некоторые {{jsxref('Statements','JavaScript условия')}} должны быть завершены точкой с запятой и поэтому на них влияет автоматическая вставка точки с запятой (ASI):</p>

<ul>
 <li>Пустое условие</li>
 <li><code>let</code>, <code>const</code>, переменные</li>
 <li><code>import</code>, <code>export</code>, объявление модулей</li>
 <li>Оператор-выражение</li>
 <li><code>debugger</code></li>
 <li><code>continue</code>, <code>break</code>, <code>throw</code></li>
 <li><code>return</code></li>
</ul>

<p>Спецификация ECMAScript напоминает о <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-rules-of-automatic-semicolon-insertion">трёх правилах вставки точки с запятой</a>.</p>

<p>1. Точка с запятой ставится до, когда ограничитель строки или "}" is encountered that is not allowed by the grammar.</p>

<pre class="brush: js notranslate">{ 1 2 } 3

// согласно ASI, будет преобразовано в

{ 1 2 ;} 3;</pre>

<p>2. Точка с запятой ставится в конце, когда обнаружен конец вводимой строки токенов и парсер is unable to parse the single input stream as a complete program.</p>

<p>Here <code>++</code> is not treated as a {{jsxref('Operators/Arithmetic_Operators','postfix operator','Increment')}} applying to variable <code>b</code>, because a line terminator occurs between <code>b</code> and <code>++</code>.</p>

<pre class="brush: js notranslate">a = b
++c

// согласно ASI, будет преобразовано в

a = b;
++c;
</pre>

<p>3. Точка с запятой вставляется в конце, когда согласно инструкции с ограниченным производством в грамматике следует ограничитель строки. Эти утверждения с правилами «no LineTerminator here» здесь:</p>

<ul>
 <li>PostfixExpressions (<code>++</code> and <code>--</code>)</li>
 <li><code>continue</code></li>
 <li><code>break</code></li>
 <li><code>return</code></li>
 <li><code>yield</code>, <code>yield*</code></li>
 <li><code>module</code></li>
</ul>

<pre class="brush: js notranslate">return
a + b

// согласно ASI, будет преобразовано в

return;
a + b;
</pre>

<h2 id="Спецификации">Спецификации</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Спецификация</th>
   <th scope="col">Статус</th>
   <th scope="col">Комментарий</th>
  </tr>
  <tr>
   <td>ECMAScript 1st Edition.</td>
   <td>Standard</td>
   <td>Первичное определение.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-7', 'Lexical Conventions')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-ecmascript-language-lexical-grammar', 'Lexical Grammar')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>Добавлено: Двоичные и восьмеричные числовые литералы, Unicode code point escapes, Шаблоны</td>
  </tr>
 </tbody>
</table>

<h2 id="Совместимость_с_браузерами">Совместимость с браузерами</h2>

<p>{{ CompatibilityTable() }}</p>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td>Binary and octal numeric literals<br>
    (<code>0b</code> and <code>0o</code>)</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatGeckoDesktop("25")}}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
  </tr>
  <tr>
   <td>Unicode code point escapes<br>
    (<code>\u{}</code>)</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatNo() }}<br>
    {{bug(952985)}}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
  </tr>
  <tr>
   <td>Shorthand notation for object literals</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatGeckoDesktop("33")}}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
  </tr>
  <tr>
   <td>Template literals</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatGeckoDesktop("34")}}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Android</th>
   <th>Chrome for Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
   <td>{{ CompatVersionUnknown() }}</td>
  </tr>
  <tr>
   <td>Binary and octal numeric literals</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{CompatGeckomobile("33")}}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
  </tr>
  <tr>
   <td>Unicode code point escapes</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatNo() }}<br>
    {{bug(952985)}}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
  </tr>
  <tr>
   <td>Shorthand notation for object literals</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{CompatGeckoMobile("33")}}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
  </tr>
  <tr>
   <td>Template literals</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{CompatGeckoMobile("34")}}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
   <td>{{ CompatNo() }}</td>
  </tr>
 </tbody>
</table>
</div>

<h2 id="Особенности_Firefox">Особенности Firefox</h2>

<ul>
 <li>Prior to Firefox 5 (JavaScript 1.8.6), future reserved keywords could be used when not in strict mode. This ECMAScript violation was fixed in Firefox 5.</li>
</ul>

<h2 id="Смотрите_также">Смотрите также:</h2>

<ul>
 <li><a href="http://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/">Jeff Walden: Двоичные и восьмеричные числа</a></li>
 <li><a href="http://mathiasbynens.be/notes/javascript-escapes">Mathias Bynens: JavaScript character escape sequences</a></li>
 <li>{{jsxref("Boolean")}}</li>
 <li>{{jsxref("Number")}}</li>
 <li>{{jsxref("RegExp")}}</li>
 <li>{{jsxref("String")}}</li>
</ul>
