---
title: Expresiones y operadores
slug: orphaned/Web/JavaScript/Guide/Expressions_and_Operators
tags:
  - Expresiones
  - Guía
  - JavaScript
  - Operadores
  - Principiante
  - '|10n_prioridad'
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
original_slug: Web/JavaScript/Guide/Expressions_and_Operators
---
<div>{{jsSidebar("JavaScript Guide", "Guía JavaScript")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>

<p class="summary">Este capítulo describe las expresiones y los operadores de JavaScript, incluyendo los de asignación, comparación, aritméticos, bit a bit, lógicos, ternarios, de cadena y otros.</p>

<p>También se encuentra disponible una lista completa y detallada de operadores y expresiones en la {{JSxRef("Operadores", "referencia")}}.</p>

<h2 id="Operadores">Operadores</h2>

<p>JavaScript tiene los siguientes tipos de operadores. Esta sección describe los operadores y contiene información sobre la precedencia de los mismos.</p>

<ul>
 <li>{{anch("Asignacion", "Operadores de asignación")}}</li>
 <li>{{anch("Comparacion", "Operadores de comparación")}}</li>
 <li>{{anch("Aritmeticos", "Operadores aritméticos")}}</li>
 <li>{{anch("Bit_a_bit", "Operadores bit a bit")}}</li>
 <li>{{anch("Logico", "Operadores lógicos")}}</li>
 <li>{{anch("Cadena", "Operadores de cadena")}}</li>
 <li>{{anch("Condicional", "Operador condicional (ternario)")}}</li>
 <li>{{anch("Coma", "Operador coma")}}</li>
 <li>{{anch("Unario", "Operadores unarios")}}</li>
 <li>{{anch("Relational", "Operadores relacionales")}}</li>
</ul>

<p>JavaScript tiene ambos operadores <em>binarios</em> y <em>unarios</em>, y un operador ternario especial, el operador condicional. Un operador binario requiere dos operandos, uno antes del operando y otro después del operador:</p>

<pre class="syntaxbox notranslate"><em>operando1</em> <em>operador</em> <em>operando2</em>
</pre>

<p>Por ejemplo, <code>3+4</code> o <code>x*y</code>.</p>

<p>Un operador unario requiere un solo operando, ya sea antes o después del operador:</p>

<pre class="syntaxbox notranslate"><em>operador</em> <em>operando</em>
</pre>

<p>o</p>

<pre class="syntaxbox notranslate"><em>operando</em> <em>operador</em>
</pre>

<p>Por ejemplo, <code>x++</code> o <code>++x</code>.</p>

<h3 id="Operadores_de_asignación"><a id="Asignacion" name="Asignacion">Operadores de asignación</a></h3>

<p>Un operador de asignación asigna un valor a su operando izquierdo basándose en el valor de su operando derecho. El operador de asignación simple es igual (<code>=</code>), que asigna el valor de su operando derecho a su operando izquierdo. Es decir, <code>x = y</code> asigna el valor de <code>y</code> a <code>x</code>.</p>

<p>También hay operadores de asignación compuestos que son una abreviatura de las operaciones enumeradas en la siguiente tabla:</p>

<table class="standard-table">
 <caption>Operadores de asignación compuestos</caption>
 <thead>
  <tr>
   <th>Nombre</th>
   <th>Operador abreviado</th>
   <th>Significado</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{JSxRef("Operadores/Assignment", "Asignación")}}</td>
   <td><code>x = y</code></td>
   <td><code>x = y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Addition_assignment", "Asignación de adición")}}</td>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Subtraction_assignment", "Asignación de resta")}}</td>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Multiplication_assignment", "Asignación de multiplicación")}}</td>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Division_assignment", "Asignación de división")}}</td>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Remainder_assignment", "Asignación de residuo")}}</td>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Exponentiation_assignment", "Asignación de exponenciación")}}</td>
   <td><code>x **= y</code></td>
   <td><code>x = x ** y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Left_shift_assignment", "Asignación de desplazamiento a la izquierda")}}</td>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Right_shift_assignment", "Asignación de desplazamiento a la derecha")}}</td>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Unsigned_right_shift_assignment", "Asignación de desplazamiento a la derecha sin signo")}}</td>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_AND_assignment", "Asignación AND bit a bit")}}</td>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_XOR_assignment", "Asignación XOR bit a bit")}}</td>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_OR_assignment", "Asignación OR bit a bit")}}</td>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Logical_AND_assignment", "Asignación AND lógico")}}</td>
   <td><code>x &amp;&amp;= y</code></td>
   <td><code>x &amp;&amp; (x = y)</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Logical_OR_assignment", "Asignación OR lógico")}}</td>
   <td><code>x ||= y</code></td>
   <td><code>x || (x = y)</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Logical_nullish_assignment", "Asignación de anulación lógica")}}</td>
   <td><code>x ??= y</code></td>
   <td><code>x ?? (x = y)</code></td>
  </tr>
 </tbody>
</table>

<h4 id="Valor_de_retorno_y_encadenamiento">Valor de retorno y encadenamiento</h4>

<p>Como la mayoría de las expresiones, asignaciones como <code>x = y</code> tienen un valor de retorno. Se puede recuperar p. ej. asignando la expresión o registrándola:</p>

<pre class="brush: bash notranslate">const z = (x = y); // O de forma equivalente: const z = x = y;

console.log(z); // Registra el valor de retorno de la asignación x = y.
console.log(x = y); // O registra el valor de retorno directamente.
</pre>

<p>El valor de retorno coincide con la expresión a la derecha del signo <code>=</code> en la columna "Significado" de la tabla anterior. Eso significa que <code>(x = y)</code> devuelve <code>y</code>, <code>(x += y)</code> devuelve la suma resultante <code>x + y</code>, <code>(x **= y)</code> devuelve la potencia resultante <code>x ** y</code>, y así sucesivamente.</p>

<p>En el caso de asignaciones lógicas, <code>(x &amp;&amp;= y)</code>, <code>(x || = y)</code> y <code>(x ??= y)</code>, el valor de retorno es el de la operación lógica sin la asignación, entonces <code>x &amp;&amp; y</code>, <code>x || y</code> y <code>x ?? y</code>, respectivamente.</p>

<p>Ten en cuenta que los valores de retorno siempre se basan en los valores de los operandos <em>antes</em> de la operación.</p>

<p>Al encadenar estas expresiones, cada asignación se evalúa de <strong>derecha a izquierda</strong>. Considera estos ejemplos:</p>

<ul>
 <li><code>w = z = x = y</code> es equivalente a <code>w = (z = (x = y))</code> o <code>x = y; z = y; w = y</code></li>
 <li><code>z += x *= y</code> es equivalente e <code>z += (x *= y)</code> o <code>tmp = x * y; x *= y; z += tmp</code> (salvo que sin <code>tmp</code>).</li>
</ul>

<h4 id="Desestructuración">Desestructuración</h4>

<p>Para asignaciones más complejas, la sintaxis de {{JSxRef("Operadores/Destructuring_assignment", "asignación de desestructuración")}} es una expresión de JavaScript que hace posible extraer datos de arreglos u objetos usando una sintaxis que refleja la construcción de arreglos y objetos literales.</p>

<pre class="brush: js notranslate">var foo = ['one', 'two', 'three'];

// sin desestructurar
var one   = foo[0];
var two   = foo[1];
var three = foo[2];

// con desestructuración
var [one, two, three] = foo;</pre>

<h3 id="Operadores_de_comparación"><a id="Comparacion" name="Comparacion">Operadores de comparación</a></h3>

<p><a id="Comparacion" name="Comparacion"> </a></p>

<p><a id="Comparacion" name="Comparacion">Un operador de comparación compara sus operandos y devuelve un valor lógico en función de si la comparación es verdadera (<code>true</code>) o falsa (<code>false</code>). Los operandos pueden ser valores numéricos, de cadena, lógicos u objetos. Las cadenas se comparan según el orden lexicográfico estándar, utilizando valores Unicode. En la mayoría de los casos, si los dos operandos no son del mismo tipo, JavaScript intenta convertirlos a un tipo apropiado para la comparación. Este comportamiento generalmente resulta en comparar los operandos numéricamente. Las únicas excepciones a la conversión de tipos dentro de las comparaciones involucran a los operadores <code>===</code> y <code>!==</code>, que realizan comparaciones estrictas de igualdad y desigualdad. Estos operadores no intentan convertir los operandos a tipos compatibles antes de verificar la igualdad. La siguiente tabla describe los operadores de comparación en términos de este código de ejemplo:</a></p>

<pre class="brush: js notranslate"><a id="Comparacion" name="Comparacion">
var var1 = 3;
var var2 = 4;
</a></pre>

<table class="standard-table">
 <caption><a id="Comparacion" name="Comparacion">Operadores de comparación</a></caption>
 <thead>
  <tr>
   <th scope="col"><a id="Comparacion" name="Comparacion">Operador</a></th>
   <th scope="col"><a id="Comparacion" name="Comparacion">Descripción</a></th>
   <th scope="col"><a id="Comparacion" name="Comparacion">Ejemplos que devuelven <code>true</code></a></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Igual", "#Igualdad")}} (<code>==</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si los operandos son iguales.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>3 == var1</code> </a>
    <p><a id="Comparacion" name="Comparacion"><code>"3" == var1</code></a></p>
    <a id="Comparacion" name="Comparacion"> <code>3 == '3'</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "No es igual", "#Desigualdad")}} (<code>!=</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si los operandos <em>no</em> son iguales.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var1 != 4<br>
    var2 != "3"</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Estrictamente igual", "#Identidad")}} (<code>===</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si los operandos son iguales y del mismo tipo. Consulta también {{JSxRef("Object.is")}} y {{JSxRef("../Equality_comparisons_and_sameness", "similitud en JS")}}.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>3 === var1</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Desigualdad estricta", "#No_Identidad")}} (<code>!==</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si los operandos son del mismo tipo pero no iguales, o son de diferente tipo.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var1 !== "3"<br>
    3 !== '3'</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("/Operadores/Comparison_Operators", "Mayor que", "#Mayor_que_el_operador")}} (<code>&gt;</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si el operando izquierdo es mayor que el operando derecho.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var2 &gt; var1<br>
    "12" &gt; 2</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Mayor o igual que", "#Operador_mayor_que_o_igual")}} (<code>&gt;=</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si el operando izquierdo es mayor o igual que el operando derecho.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Menor que", "#Operador_menor_que")}} (<code>&lt;</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si el operando izquierdo es menor que el operando derecho.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var1 &lt; var2<br>
    "2" &lt; 12</code></a></td>
  </tr>
  <tr>
   <td><a id="Comparacion" name="Comparacion">{{JSxRef("Operadores/Comparison_Operators", "Menor o igual", "#Operador_menor_que_o_igual")}} (<code>&lt;=</code>)</a></td>
   <td><a id="Comparacion" name="Comparacion">Devuelve <code>true</code> si el operando izquierdo es menor o igual que el operando derecho.</a></td>
   <td><a id="Comparacion" name="Comparacion"><code>var1 &lt;= var2<br>
    var2 &lt;= 5</code></a></td>
  </tr>
 </tbody>
</table>

<div class="note">
<p><a id="Comparacion" name="Comparacion"><strong>Nota</strong>: (<strong>=&gt;</strong>) no es un operador, sino la notación para {{JSxRef("Funciones/Arrow_functions", "Funciones flecha")}}.</a></p>
</div>

<h3 id="Operadores_aritméticos"><a id="Comparacion" name="Comparacion"></a><a id="Aritmeticos" name="Aritmeticos">Operadores aritméticos</a></h3>

<p>Un operador aritmético toma valores numéricos (ya sean literales o variables) como sus operandos y devuelve un solo valor numérico. Los operadores aritméticos estándar son suma (<code>+</code>), resta (<code>-</code>), multiplicación (<code>*</code>) y división (<code>/</code>). Estos operadores funcionan como lo hacen en la mayoría de los otros lenguajes de programación cuando se usan con números de punto flotante (en particular, ten en cuenta que la división entre cero produce {{JSxRef("Infinity")}}). Por ejemplo:</p>

<pre class="brush: js notranslate">1 / 2; // 0.5
1 / 2 == 1.0 / 2.0; // Esto es true
</pre>

<p>Además de las operaciones aritméticas estándar (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), JavaScript proporciona los operadores aritméticos enumerados en la siguiente tabla:</p>

<table class="fullwidth-table">
 <caption>Operadores aritméticos</caption>
 <thead>
  <tr>
   <th scope="col">Operador</th>
   <th scope="col">Descripción</th>
   <th scope="col">Ejemplo</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{JSxRef("Operadores/Remainder", "Residuo")}} (<code>%</code>)</td>
   <td>Operador binario. Devuelve el resto entero de dividir los dos operandos.</td>
   <td>12 % 5 devuelve 2.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Increment", "Incremento")}} (<code>++</code>)</td>
   <td>Operador unario. Agrega uno a su operando. Si se usa como operador prefijo (<code>++x</code>), devuelve el valor de su operando después de agregar uno; si se usa como operador sufijo (<code>x++</code>), devuelve el valor de su operando antes de agregar uno.</td>
   <td>Si <code>x</code> es 3, <code>++x</code> establece <code>x</code> en 4 y devuelve 4, mientras que <code>x++</code> devuelve 3 y , solo entonces, establece <code>x</code> en 4.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Decrement", "Decremento")}} (<code>--</code>)</td>
   <td>Operador unario. Resta uno de su operando. El valor de retorno es análogo al del operador de incremento.</td>
   <td>Si <code>x</code> es 3, entonces <code>--x</code> establece <code>x</code> en 2 y devuelve 2, mientras que <code>x--</code> devuelve 3 y, solo entonces, establece <code>x</code> en 2.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Unary_negation", "Negación unaria")}} (<code>-</code>)</td>
   <td>Operador unario. Devuelve la negación de su operando.</td>
   <td>Si <code>x</code> es 3, entonces <code>-x</code> devuelve -3.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Unary_plus", "Positivo unario")}} (<code>+</code>)</td>
   <td>Operador unario. Intenta convertir el operando en un número, si aún no lo es.</td>
   <td><code>+"3"</code> devuelve <code>3</code>.<br>
    <code>+true</code> devuelve <code>1.</code></td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Exponentiation", "Operador de exponenciación")}} (<code>**</code>)</td>
   <td>Calcula la <code>base</code> a la potencia de <code>exponente</code>, es decir, <code>base<sup>exponente</sup></code></td>
   <td><code>2 ** 3</code> returns <code>8</code>.<br>
    <code>10 ** -1</code> returns <code>0.1</code>.</td>
  </tr>
 </tbody>
</table>

<h3 id="Operadores_bit_a_bit"><a id="Bit_a_bit" name="Bit_a_bit">Operadores bit a bit</a></h3>

<p>Un operador bit a bit trata a sus operandos como un conjunto de 32 bits (ceros y unos), en lugar de números decimales, hexadecimales u octales. Por ejemplo, el número decimal nueve tiene una representación binaria de 1001. Los operadores bit a bit realizan sus operaciones en tales representaciones binarias, pero devuelven valores numéricos estándar de JavaScript.</p>

<p>La siguiente tabla resume los operadores bit a bit de JavaScript.</p>

<table class="standard-table">
 <caption>Operadores bit a bit</caption>
 <thead>
  <tr>
   <th scope="col">Operador</th>
   <th scope="col">Uso</th>
   <th scope="col">Descripción</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_AND", "AND a nivel de bits")}}</td>
   <td><code>a &amp; b</code></td>
   <td>Devuelve un uno en cada posición del bit para los que los bits correspondientes de ambos operandos son unos.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_OR", "OR a nivel de bits")}}</td>
   <td><code>a | b</code></td>
   <td>Devuelve un cero en cada posición de bit para el cual los bits correspondientes de ambos operandos son ceros.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_XOR", "XOR a nivel de bits")}}</td>
   <td><code>a ^ b</code></td>
   <td>Devuelve un cero en cada posición de bit para la que los bits correspondientes son iguales.<br>
    [Devuelve uno en cada posición de bit para la que los bits correspondientes son diferentes].</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Bitwise_NOT", "NOT a nivel de bits")}}</td>
   <td><code>~ a</code></td>
   <td>Invierte los bits de su operando.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Left_shift", "Desplazamiento a la izquierda")}}</td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Desplaza <code>a</code> en representación binaria <code>b</code> bits hacia la izquierda, desplazándose en ceros desde la derecha.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Right_shift", "Desplazamiento a la derecha de propagación de signo")}}</td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Desplaza <code>a</code> en representación binaria <code>b</code> bits a la derecha, descartando los bits desplazados.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Unsigned_right_shift", "Desplazamiento a la derecha de relleno cero")}}</td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>Desplaza <code>a</code> en representación binaria <code>b</code> bits hacia la derecha, descartando los bits desplazados y desplazándose en ceros desde la izquierda.</td>
  </tr>
 </tbody>
</table>

<h4 id="Operadores_logicos_bit_a_bit" name="Operadores_logicos_bit_a_bit">Operadores lógicos bit a bit</h4>

<p>Conceptualmente, los operadores lógicos bit a bit funcionan de la siguiente manera:</p>

<ul>
 <li>Los operandos se convierten en enteros de treinta y dos bits y se expresan mediante una serie de bits (ceros y unos). A los números con más de 32 bits se les descartan los bits más significativos. Por ejemplo, el siguiente número entero con más de 32 bits se convertirá en un número entero de 32 bits:
  <pre class="brush: bash notranslate">Antes:  1110<code> </code>0110<code> </code>1111<code> </code>1010<code> </code>0000<code> </code>0000<code> </code>0000<code> </code>0110<code> </code>0000<code> </code>0000<code> </code>0001
Después:               1010<code> </code>0000<code> </code>0000<code> </code>0000<code> </code>0110<code> </code>0000<code> </code>0000<code> </code>0001</pre>
 </li>
 <li>Cada bit en el primer operando se empareja con el bit correspondiente en el segundo operando: primer bit al primer bit, segundo bit al segundo bit, y así sucesivamente.</li>
 <li>El operador se aplica a cada par de bits y el resultado se construye bit a bit.</li>
</ul>

<p>Por ejemplo, la representación binaria de nueve es 1001 y la representación binaria de quince es 1111. Entonces, cuando los operadores bit a bit se aplican a estos valores, los resultados son los siguientes:</p>

<table class="standard-table">
 <caption>Ejemplos de operadores bit a bit</caption>
 <thead>
  <tr>
   <th scope="col">Expresión</th>
   <th scope="col">Resultado</th>
   <th scope="col">Descripción binaria</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~ 0000 0000 ... 0000 1111 = 1111 1111 ... 1111 0000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~ 0000 0000 ... 0000 1001 = 1111 1111 ... 1111 0110</code></td>
  </tr>
 </tbody>
</table>

<p>Ten en cuenta que los 32 bits se invierten utilizando el operador <code>NOT</code> a nivel de bits y que los valores con el bit más significativo (más a la izquierda) establecido en 1 representan números negativos (representación en complemento a dos). <code>~x</code> evalúa al mismo valor que evalúa <code>-x - 1</code>.</p>

<h4 id="Operadores_de_desplazamiento_de_bits" name="Operadores_de_desplazamiento_de_bits">Operadores de desplazamiento de bits</h4>

<p>Los operadores de desplazamiento bit a bit toman dos operandos: el primero es una cantidad que se va a desplazar y el segundo especifica el número de posiciones de bit por las que se va a desplazar el primer operando. La dirección de la operación de desplazamiento es controlada por el operador utilizado.</p>

<p>Los operadores de desplazamiento convierten sus operandos en enteros de treinta y dos bits y devuelven un resultado del mismo tipo que el operando izquierdo.</p>

<p>Los operadores de desplazamiento se enumeran en la siguiente tabla.</p>

<table class="fullwidth-table">
 <caption>Operadores de desplazamiento de bits</caption>
 <thead>
  <tr>
   <th scope="col">Operador</th>
   <th scope="col">Descripción</th>
   <th scope="col">Ejemplo</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{JSxRef("Operadores/Left_shift", "Desplazamiento a la izquierda")}}<br>
    (<code>&lt;&lt;</code>)</td>
   <td>Este operador desplaza el primer operando el número especificado de bits a la izquierda. Los bits desplazados en exceso hacia la izquierda se descartan. Los bits cero se desplazan desde la derecha.</td>
   <td><code>9&lt;&lt;2</code> produce 36, porque 1001 desplazado 2 bits a la izquierda se convierte en 100100, que es 36.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Right_shift", "Desplazamiento a la derecha de propagación de signo")}} (<code>&gt;&gt;</code>)</td>
   <td>Este operador desplaza el primer operando el número especificado de bits a la derecha. Los bits desplazados en exceso hacia la derecha se descartan. Las copias del bit más a la izquierda se desplazan desde la izquierda.</td>
   <td><code>9&gt;&gt;2</code> produce 2, porque 1001 desplazado 2 bits a la derecha se convierte en 10, que es 2. Del mismo modo, <code>-9&gt;&gt;2</code> produce -3, porque el signo se conserva.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Unsigned_right_shift", "Desplazamiento a la derecha de relleno cero")}} (<code>&gt;&gt;&gt;</code>)</td>
   <td>Este operador desplaza el primer operando el número especificado de bits a la derecha. Los bits desplazados en exceso hacia la derecha se descartan. Los bits cero se desplazan desde la izquierda.</td>
   <td><code>19&gt;&gt;&gt;2</code> produce 4, porque 10011 desplazado 2 bits a la derecha se convierte en 100, que es 4. Para números no negativos, el desplazamiento a la derecha de relleno con ceros y el desplazamiento a la derecha de propagación del signo producen el mismo resultado.</td>
  </tr>
 </tbody>
</table>

<h3 id="Operadores_lógicos"><a id="Logico" name="Logico">Operadores lógicos</a></h3>

<p>Los operadores lógicos se utilizan normalmente con valores booleanos (lógicos); cuando lo son, devuelven un valor booleano. Sin embargo, los operadores <code>&amp;&amp;</code> y <code>||</code> en realidad devuelven el valor de uno de los operandos especificados, por lo que si estos operadores se utilizan con valores no booleanos, pueden devolver un valor no booleano. Los operadores lógicos se describen en la siguiente tabla.</p>

<table class="fullwidth-table">
 <caption>Operadores lógicos</caption>
 <thead>
  <tr>
   <th scope="col">Operador</th>
   <th scope="col">Uso</th>
   <th scope="col">Descripción</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{JSxRef("Operadores/Logical_AND", "AND Lógico")}} (<code>&amp;&amp;</code>)</td>
   <td><code>expr1 &amp;&amp; expr2</code></td>
   <td>Devuelve <code>expr1</code> si se puede convertir a <code>false</code>; de lo contrario, devuelve <code>expr2</code>. Por lo tanto, cuando se usa con valores booleanos, <code>&amp;&amp;</code> devuelve <code>true</code> si ambos operandos son <code>true</code>; de lo contrario, devuelve <code>false</code>.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Logical_OR", "OR lógico")}} (<code>||</code>)</td>
   <td><code>expr1 || expr2</code></td>
   <td>Devuelve <code>expr1</code> si se puede convertir a <code>true</code>; de lo contrario, devuelve <code>expr2</code>. Por lo tanto, cuando se usa con valores booleanos, <code>||</code> devuelve <code>true</code> si alguno de los operandos es <code>true</code>; si ambos son falsos, devuelve <code>false</code>.</td>
  </tr>
  <tr>
   <td>{{JSxRef("Operadores/Logical_NOT", "NOT lógico")}} (<code>!</code>)</td>
   <td><code>!expr</code></td>
   <td>Devuelve <code>false</code> si su único operando se puede convertir a <code>true</code>; de lo contrario, devuelve <code>true</code>.</td>
  </tr>
 </tbody>
</table>

<p>Ejemplos de expresiones que se pueden convertir a <code>false</code> son aquellos que se evalúan como <code>null</code>, 0, <code>NaN</code>, la cadena vacía ("") o <code>undefined</code>.</p>

<p>El siguiente código muestra ejemplos del operador <code>&amp;&amp;</code> (<code>AND</code> lógico).</p>

<pre class="brush: js notranslate">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t devuelve true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f devuelve false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t devuelve false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f devuelve false
var a5 = 'Cat' &amp;&amp; 'Dog';    // t &amp;&amp; t devuelve Dog
var a6 = false &amp;&amp; 'Cat';    // f &amp;&amp; t devuelve false
var a7 = 'Cat' &amp;&amp; false;    // t &amp;&amp; f devuelve false
</pre>

<p>El siguiente código muestra ejemplos del operador || (<code>OR</code> lógico).</p>

<pre class="brush: js notranslate">var o1 =  true || true;     // t || t devuelve true
var o2 = false || true;     // f || t devuelve true
var o3 =  true || false;    // t || f devuelve true
var o4 = false || (3 == 4); // f || f devuelve false
var o5 = 'Cat' || 'Dog';    // t || t devuelve Cat
var o6 = false || 'Cat';    // f || t devuelve Cat
var o7 = 'Cat' || false;    // t || f devuelve Cat
</pre>

<p>El siguiente código muestra ejemplos de el operador ! (<code>NOT</code> lógico).</p>

<pre class="brush: js notranslate">var n1 = !true;  // !t devuelve false
var n2 = !false; // !f devuelve true
var n3 = !'Cat'; // !t devuelve false
</pre>

<h4 id="Evaluacion_de_cortocircuito" name="Evaluacion_de_cortocircuito">Evaluación de cortocircuito</h4>

<p>Debido a que las expresiones lógicas se evalúan de izquierda a derecha, se prueban para una posible evaluación de "cortocircuito" utilizando las siguientes reglas:</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>anything</em> se evalúa en cortocircuito como <code>false</code>.</li>
 <li><code>true</code> || <em>anything</em> se evalúa en cortocircuito como <code>true</code>.</li>
</ul>

<p>Las reglas de la lógica garantizan que estas evaluaciones sean siempre correctas. Ten en cuenta que la parte <em>anything</em> de las expresiones anteriores no se evalúa, por lo que los efectos secundarios de hacerlo no surten efecto.</p>

<p>Ten en cuenta que para el segundo caso, en el código moderno puedes usar el nuevo {{JSxRef("Operadores/Nullish_coalescing_operator", "operador de fusión nulo")}} (<code>??</code>) que funciona como <code>||</code>, pero solo devuelve la segunda expresión, cuando la primera es "{{Glossary("Nullish", "nullish")}}", es decir, {{JSxRef("Objetos_globales/null", "null")}}, el valor nulo representa la ausencia intencional de cualquier valor de objeto. Es uno de los valores primitivos de JavaScript y se trata como falso para las operaciones booleanas. o {{JSxRef("Objetos_globales/undefined", "undefined")}} la propiedad global undefined representa el valor "<code>undefined</code>" primitivo. Es uno de los tipos primitivos de JavaScript. Por tanto, es la mejor alternativa para proporcionar valores predeterminados, cuando valores como <code>''</code> o <code>0</code> también son valores válidos para la primera expresión.</p>

<h3 id="Operadores_de_cadena"><a id="Cadena" name="Cadena">Operadores de cadena</a></h3>

<p>Además de los operadores de comparación, que se pueden usar en valores de cadena, el operador de concatenación (+) concatena dos valores de cadena, devolviendo otra cadena que es la unión de los dos operandos de cadena.</p>

<p>Por ejemplo,</p>

<pre class="brush: js notranslate">console.log('mi ' + 'cadena'); // la consola registra la cadena "mi cadena".</pre>

<p>El operador de asignación abreviada <code>+=</code> también se puede utilizar para concatenar cadenas.</p>

<p>Por ejemplo,</p>

<pre class="brush: js notranslate">var mystring = 'alpha';
mystring += 'bet'; // se evalúa como "alphabet" y asigna este valor a mystring.</pre>

<h3 id="Operador_condicional_ternario"><a id="Condicional" name="Condicional">Operador condicional (ternario)</a></h3>

<p>El {{JSxRef("Operadores/Conditional_Operator", "operador condicional")}} es el único operador de JavaScript que toma tres operandos. El operador puede tener uno de dos valores según una condición. La sintaxis es:</p>

<pre class="syntaxbox notranslate"><em>condition</em> ? <em>val1</em> : <em>val2</em>
</pre>

<p>Si <code>condition</code> es <code>true</code>, el operador tiene el valor de <code>val1</code>. De lo contrario, tiene el valor de <code>val2</code>. Puedes utilizar el operador condicional en cualquier lugar donde normalmente utilizas un operador estándar.</p>

<p>Por ejemplo,</p>

<pre class="brush: js notranslate">var status = (age &gt;= 18) ? 'adult' : 'minor';
</pre>

<p>Esta declaración asigna el valor "<code>adult</code>" a la variable <code>status</code> si <code>age</code> es de dieciocho años o más. De lo contrario, asigna el valor "<code>minor</code>" a <code>status</code>.</p>

<h3 id="Operador_coma" name="Operador_coma"><a id="Coma" name="Coma">Operador coma</a></h3>

<p>El {{JSxRef("Operadores/Comma_Operator", "operador coma")}} (<code>,</code>) simplemente evalúa ambos operandos y devuelve el valor del último operando. Este operador se utiliza principalmente dentro de un bucle <code>for</code>, para permitir que se actualicen múltiples variables cada vez a través del bucle. Se considera de mal estilo usarlo en otros lugares, cuando no es necesario. A menudo, en su lugar pueden y se deben utilizar dos declaraciones independientes.</p>

<p>Por ejemplo, si <code>a</code> es un arreglo bidimensional con 10 elementos en un lado, el siguiente código usa el operador <code>coma</code> para actualizar dos variables a la vez. El código imprime los valores de los elementos diagonales en el arreglo:</p>

<pre class="brush: js notranslate">var x = [0,1,2,3,4,5,6,7,8,9]
var a = [x, x, x, x, x];

for (var i = 0, j = 9; i &lt;= j; i++, j--)
//                                ^
  console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
</pre>

<h3 id="Operadores_unarios"><a id="Unario" name="Unario">Operadores unarios</a></h3>

<p>Una operación unaria es una operación con un solo operando.</p>

<h4 id="delete" name="delete"><code>delete</code></h4>

<p>El operador {{JSxRef("Operadores/delete", "delete")}} elimina la propiedad de un objeto. La sintaxis es:</p>

<pre class="brush: js notranslate">delete object.property;
delete object[propertyKey];
delete objectName[index];
delete property; // legal solo dentro de una declaración with
</pre>

<p>donde <code>object</code> es el nombre de un objeto, <code>property</code> es una propiedad existente y <code>propertyKey</code> es una cadena o símbolo que hace referencia a una propiedad existente.</p>

<p>La cuarta forma es legal solo dentro de una declaración {{JSxRef("Sentencias/with", "with")}}, para eliminar una propiedad de un objeto, y también para las propiedades del objeto global.</p>

<p>Si el operador <code>delete</code> tiene éxito, elimina la propiedad del objeto. Intentar acceder a él después dará como resultado <code>undefined</code>. El operador <code>delete</code> devuelve <code>true</code> si la operación es posible; devuelve <code>false</code> si la operación no es posible.</p>

<pre class="brush: js notranslate">x = 42; // implícitamente crea window.x
var y = 43;
var myobj = {h: 4}; // crea un objeto con la propiedad h

delete x;       // devuelve true (se puede eliminar si se crea implícitamente)
delete y;       // devuelve false (no se puede borrar si se declara con var)
delete Math.PI; // devuelve false (no se pueden eliminar propiedades no configurables)
delete myobj.h; // devuelve true (puede eliminar propiedades definidas por el usuario)
</pre>

<h5 id="Eliminar_elementos_de_un_arreglo">Eliminar elementos de un arreglo</h5>

<p>Dado que los arreglos solo son objetos, técnicamente es posible <code>delete</code> elementos de ellos. Sin embargo, esto se considera una mala práctica, trata de evitarlo. Cuando eliminas una propiedad de arreglo, la longitud del arreglo no se ve afectada y otros elementos no se vuelven a indexar. Para lograr ese comportamiento, es mucho mejor simplemente sobrescribir el elemento con el valor <code>undefined</code>. Para manipular realmente el arreglo, usa los diversos métodos de arreglo, como {{JSxRef("Objetos_globales/Array/splice", "splice")}}.</p>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p>El {{JSxRef("Operadores/typeof", "operador typeof")}} se utiliza de cualquiera de las siguientes formas:</p>

<pre class="syntaxbox notranslate">typeof operand
typeof (operand)
</pre>

<p>El operador <code>typeof</code> devuelve una cadena que indica el tipo de operando no evaluado. <code>operando</code> es la cadena, variable, palabra clave u objeto para el que se devolverá el tipo. Los paréntesis son opcionales.</p>

<p>Supón que defines las siguientes variables:</p>

<pre class="brush: js notranslate">var myFun = new Function('5 + 2');
var shape = 'round';
var size = 1;
var foo = ['Apple', 'Mango', 'Orange'];
var today = new Date();
</pre>

<p>El operador <code>typeof</code> devuelve los siguientes resultados para estas variables:</p>

<pre class="brush: js notranslate">typeof myFun;       // devuelve "function"
typeof shape;       // devuelve "string"
typeof size;        // devuelve "number"
typeof foo;         // devuelve "object"
typeof today;       // devuelve "object"
typeof doesntExist; // devuelve "undefined"
</pre>

<p>Para las palabras clave <code>true</code> y <code>null</code>, el operador <code>typeof</code> devuelve los siguientes resultados:</p>

<pre class="brush: js notranslate">typeof true; // devuelve "boolean"
typeof null; // devuelve "object"
</pre>

<p>Para un número o cadena, el operador <code>typeof</code> devuelve los siguientes resultados:</p>

<pre class="brush: js notranslate">typeof 62;            // devuelve "number"
typeof 'Hola mundo';  // devuelve "string"
</pre>

<p>Para los valores de propiedad, el operador <code>typeof</code> devuelve el tipo de valor que contiene la propiedad:</p>

<pre class="brush: js notranslate">typeof document.lastModified; // devuelve "string"
typeof window.length;         // devuelve "number"
typeof Math.LN2;              // devuelve "number"
</pre>

<p>Para métodos y funciones, el operador <code>typeof</code> devuelve los siguientes resultados:</p>

<pre class="brush: js notranslate">typeof blur;        // devuelve "function"
typeof eval;        // devuelve "function"
typeof parseInt;    // devuelve "function"
typeof shape.split; // devuelve "function"
</pre>

<p>Para objetos predefinidos, el operador <code>typeof</code> devuelve los siguientes resultados:</p>

<pre class="brush: js notranslate">typeof Date;     // devuelve "function"
typeof Function; // devuelve "function"
typeof Math;     // devuelve "object"
typeof Option;   // devuelve "function"
typeof String;   // devuelve "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p>El {{JSxRef("Operadores/void", "operador void")}} se utiliza de cualquiera de las siguientes formas:</p>

<pre class="syntaxbox notranslate">void (expression)
void expression
</pre>

<p>El operador <code>void</code> especifica una expresión que se evaluará sin devolver un valor. <code>expression</code> es una expresión de JavaScript para evaluar. Los paréntesis que rodean la expresión son opcionales, pero es un buen estilo usarlos.</p>

<h3 id="Operadores_relacionales"><a id="Relacional" name="Relacional">Operadores relacionales</a></h3>

<p>Un operador relacional compara sus operandos y devuelve un valor <code>Boolean</code> basado en si la comparación es verdadera.</p>

<h4 id="in"><code>in</code></h4>

<p>El {{JSxRef("Operadores/in", "operador in")}} devuelve <code>true</code> si la propiedad especificada está en el objeto especificado. La sintaxis es:</p>

<pre class="brush: js notranslate">propNameOrNumber in objectName
</pre>

<p>donde <code>propNameOrNumber</code> es una expresión de cadena, numérica o de símbolo que representa un nombre de propiedad o índice de arreglo, y <code>objectName</code> es el nombre de un objeto.</p>

<p>Los siguientes ejemplos muestran algunos usos del operador <code>in</code>.</p>

<pre class="brush: js notranslate">// Arreglos
var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
0 in trees;        // devuelve true
3 in trees;        // devuelve true
6 in trees;        // devuelve false
'bay' in trees;    // devuelve false (debes especificar el número del índice,
                   // no el valor en ese índice)
'length' en trees; // devuelve true (la longitud es una propiedad de Array)

// objetos integrados
'PI' in Math;          // devuelve true
var myString = new String('coral');
'length' in myString;  // devuelve true

// Objetos personalizados
var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
'make' in mycar;  // devuelve true
'model' in mycar; // devuelve true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p>El {{JSxRef("Operadores/instanceof", "operador instanceof")}} devuelve <code>true</code> si el objeto especificado es del tipo de objeto especificado. La sintaxis es:</p>

<pre class="syntaxbox notranslate">objectName instanceof objectType
</pre>

<p>donde <code>objectName</code> es el nombre del objeto para comparar con <code>objectType</code>, y <code>objectType</code> es un tipo de objeto, como {{JSxRef("Date")}} o {{JSxRef("Array")}}.</p>

<p>Utiliza <code>instanceof</code> cuando necesites confirmar el tipo de un objeto en tiempo de ejecución. Por ejemplo, al detectar excepciones, puedes ramificar a diferentes controladores según el tipo de excepción lanzada.</p>

<p>Por ejemplo, el siguiente código usa <code>instanceof</code> para determinar si <code>theDay</code> es un objeto <code>Date</code>. Debido a que <code>theDay</code> es un objeto <code>Date</code>, las instrucciones de la expresión <code>if</code> se ejecutan.</p>

<pre class="brush: js notranslate">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // instrucciones a ejecutar
}
}
</pre>

<h3 id="Precedencia_de_los_operadores">Precedencia de los operadores</h3>

<p>La <em>precedencia</em> de los operadores determina el orden en que se aplican al evaluar una expresión. Puedes redefinir la precedencia de los operadores mediante el uso de paréntesis.</p>

<p>La siguiente tabla describe la precedencia de los operadores, de mayor a menor.</p>

<table class="standard-table">
 <caption>Precedencia de los operadores</caption>
 <thead>
  <tr>
   <th scope="col">Tipo de operador</th>
   <th scope="col">Operadores individuales</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>miembro</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>llamar / crear instancia</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>negación / incremento</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>multiplicar / dividir</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>adición / sustracción</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>desplazamiento bit a bit</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>relacional</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>igualdad</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td><code>AND</code> bit a bit</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td><code>XOR</code> bit a bit</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td><code>OR</code> bit a bit</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td><code>AND</code> lógico</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td><code>OR</code> lógico</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>condicional</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>asignación</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |= &amp;&amp;= ||= ??=</code></td>
  </tr>
  <tr>
   <td>coma</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>Puedes encontrar una versión más detallada de esta tabla, completa con enlaces a detalles adicionales sobre cada operador, en {{JSxRef("Operadores/Operator_Precedence", "Referencia de JavaScript", "#Table")}}.</p>

<h2 id="Expresiones">Expresiones</h2>

<p>Una <em>expresión</em> es cualquier unidad de código válida que se resuelve en un valor.</p>

<p>Toda expresión sintácticamente válida se resuelve en algún valor, pero conceptualmente, hay dos tipos de expresiones: con efectos secundarios (por ejemplo: las que asignan valor a una variable) y las que en algún sentido evalúan y por lo tanto se resuelven en un valor.</p>

<p>La expresión <code>x = 7</code> es un ejemplo del primer tipo. Esta expresión usa el <em>operador</em> = para asignar el valor siete a la variable <code>x</code>. La expresión en sí se evalúa como siete.</p>

<p>El código <code>3 + 4</code> es un ejemplo del segundo tipo de expresión. Esta expresión usa el operador + para sumar tres y cuatro sin asignar el resultado, siete, a una variable.<br>
 <br>
 JavaScript tiene las siguientes categorías de expresión:</p>

<ul>
 <li>Aritméticas: se evalúa como un número, por ejemplo 3.14159. (Generalmente usa {{anch("#Aritméticos", "operadores aritméticos")}}).</li>
 <li>Cadenas: se evalúa como una cadena de caracteres, por ejemplo, "Fred" o "234". (Generalmente usa {{anch("Cadena", "operadores de cadena")}}).</li>
 <li>Lógicas: se evalúan como <code>true</code> o <code>false</code>. (A menudo implica {{anch("Logico", "operadores lógicos")}}).</li>
 <li>Expresiones primarias: palabras clave básicas y expresiones generales en JavaScript.</li>
 <li>Expresiones del lado izquierdo: los valores del lado izquierdo son el destino de una asignación.</li>
</ul>

<h3 id="Expresiones_primarias">Expresiones primarias</h3>

<p>Palabras clave básicas y expresiones generales en JavaScript.</p>

<h4 id="this" name="this"><code>this</code></h4>

<p>Utiliza la {{JSxRef("Operadores/this", "palabra clave this")}} para hacer referencia al objeto actual. En general, <code>this</code> se refiere al objeto que llama en un método. Usa <code>this</code> con la notación de punto o entre corchetes:</p>

<pre class="syntaxbox notranslate">this['propertyName']
this.propertyName
</pre>

<p>Supongamos que una función llamada <code>validate</code> valida la propiedad <code>value</code> de un objeto, dado el objeto y los valores alto y bajo:</p>

<pre class="brush: js notranslate">function validate(obj, lowval, hival) {
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    console.log('¡Valor no válido!');
}
</pre>

<p>Puedes llamar a <code>validate</code> en el controlador de eventos <code>onChange</code> de cada elemento de formulario, utilizando <code>this</code> para pasarlo al elemento de formulario, como en el siguiente ejemplo:</p>

<pre class="brush: html notranslate">&lt;p&gt;Ingresa un número entre 18 y 99:&lt;/p&gt;
&lt;input type="text" name="age" size=3 onChange="validate(this, 18, 99);"&gt;
</pre>

<h4 id="Operador_de_agrupación">Operador de agrupación</h4>

<p>El operador de agrupación <code>()</code> controla la precedencia de la evaluación en las expresiones. Por ejemplo, puedes redefinir la multiplicación y la división primero, luego la suma y la resta para evaluar la suma primero.</p>

<pre class="brush:js notranslate">var a = 1;
var b = 2;
var c = 3;

// precedencia predeterminada
a + b * c     // 7
// evaluado por omisión así
a + (b * c)   // 7

// ahora prevalece sobre la precedencia
// suma antes de multiplicar
(a + b) * c   // 9

// que es equivalente a
a * c + b * c // 9
</pre>

<h3 id="Expresiones_del_lado_izquierdo">Expresiones del lado izquierdo</h3>

<p>Los valores de la izquierda son el destino de una asignación.</p>

<h4 id="new" name="new"><code>new</code></h4>

<p>Puedes utilizar el {{JSxRef("Operadores/new", "operador new")}} para crear una instancia de un tipo de objeto definido por el usuario o de uno de los tipos de objeto integrados. Utiliza <code>new</code> de la siguiente manera:</p>

<pre class="brush: js notranslate">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<h4 id="super"><code>super</code></h4>

<p>La {{JSxRef("Operadores/super", "palabra clave super")}} se utiliza para llamar a funciones en el padre de un objeto. Es útil con {{JSxRef("Classes", "clases")}} llamar al constructor padre, por ejemplo.</p>

<pre class="syntaxbox notranslate">super([arguments]); // llama al constructor padre.
super.functionOnParent([arguments]);
</pre>

<div>{{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>
