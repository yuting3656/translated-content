---
title: Body
slug: orphaned/Web/API/Body
tags:
  - API
  - BODY
  - Fetch
  - bolb()
  - json()
  - request
translation_of: Web/API/Body
original_slug: Web/API/Body
---
<p>{{ APIRef("Fetch") }}</p>

<p><a href="/en-US/docs/Web/API/Fetch_API">Fetch API</a> 中的 <strong><code>Body</code></strong> {{glossary("mixin")}} 代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。</p>

<p><code>Body</code>被{{domxref("Request")}} 和{{domxref("Response")}}实现，并为这些对象提供了一个相关联的主体（字节流），一个已使用的标志（最初未设置）和一个MIME类型（最初为空字节序列）。</p>

<h2 id="属性">属性</h2>

<dl>
 <dt>{{domxref("Body.body")}} {{readonlyInline}}</dt>
 <dd>一个简单的getter用于暴露一个{{domxref("ReadableStream")}}类型的主体内容。</dd>
 <dt>{{domxref("Body.bodyUsed")}} {{readonlyInline}}</dt>
 <dd>一个{{domxref("Boolean")}} 值指示是否body已经被标记读取。</dd>
</dl>

<h2 id="方法">方法</h2>

<dl>
 <dt>{{domxref("Body.arrayBuffer()")}}</dt>
 <dd>使{{domxref("Response")}}挂起一个流操作并且在完成时读取其值，它返回一个{{domxref("Promise")}}对象，其resolve参数类型是{{domxref("ArrayBuffer")}}。此操作会将bodyUsed状态改为已使用（true）。</dd>
 <dt>{{domxref("Body.blob()")}}</dt>
 <dd>使{{domxref("Response")}}挂起一个流操作并且在完成时读取其值，它返回一个{{domxref("Promise")}}对象，其resolve参数类型是{{domxref("Blob")}}。此操作会将bodyUsed状态改为已使用（true）。</dd>
 <dt>{{domxref("Body.formData()")}}</dt>
 <dd>使{{domxref("Response")}}挂起一个流操作并且在完成时读取其值，它返回一个{{domxref("Promise")}}对象，其resolve参数类型是{{domxref("FormData")}}表单。此操作会将bodyUsed状态改为已使用（true）。</dd>
 <dt>{{domxref("Body.json()")}}</dt>
 <dd>使{{domxref("Response")}}挂起一个流操作并且在完成时读取其值，它返回一个{{domxref("Promise")}}对象，其resolve参数类型是使用{{jsxref("JSON")}}解析body文本的结果。此操作会将bodyUsed状态改为已使用（true）。</dd>
 <dt>{{domxref("Body.text()")}}</dt>
 <dd>使{{domxref("Response")}}挂起一个流操作并且在完成时读取其值，它返回一个{{domxref("Promise")}}对象，其resolve参数类型是{{domxref("USVString")}}（文本）。此操作会将bodyUsed状态改为已使用（true）。</dd>
</dl>

<h2 id="范例">范例</h2>

<p>在<a href="https://github.com/mdn/fetch-examples/tree/gh-pages/basic-fetch">基本 fetch 使用实例</a> (<a href="http://mdn.github.io/fetch-examples/basic-fetch/">查看运行效果</a>) 中，我们使用简单的 fetch 请求获取一张图片并将其使用 {{htmlelement("img")}} 标签展示。你可能注意到当我们请求一张图片，需要使用 {{domxref("Body.blob")}} ({{domxref("Response")}} 实现 body 接口以发送正确的MIME类型给服务器进行识别。</p>

<h3 id="HTML_内容">HTML 内容</h3>

<pre class="brush: html">&lt;img class="my-image" src="https://wikipedia.org/static/images/project-logos/frwiki-1.5x.png"&gt;
</pre>

<h3 id="JS_内容">JS 内容</h3>

<pre class="brush: js">var myImage = document.querySelector('.my-image');
fetch('flowers.jpg').then(function(response) {
  return response.blob();
}).then(function(response) {
  var objectURL = URL.createObjectURL(response);
  myImage.src = objectURL;
});</pre>

<p>你也可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/Response" title="The Response() constructor creates a new Response object."><code>Response.Response()</code></a> 构造函数创建自定义的 <code>Response</code> 对象。</p>

<pre><code>const response = new Response();</code>
</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('Fetch','#body-mixin','Body')}}</td>
   <td>{{Spec2('Fetch')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容情况">浏览器兼容情况</h2>

<div class="hidden">
<p>此兼容性表是从结构化数据生成的。如果您想贡献数据，请check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> 并向我们发送pull请求。</p>
</div>

<p>{{Compat("api.Body")}}</p>

<h2 id="也可以看看">也可以看看</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/ServiceWorker_API">ServiceWorker API</a></li>
 <li><a href="/en-US/docs/Web/HTTP/Access_control_CORS">HTTP access control (CORS)</a></li>
 <li><a href="/en-US/docs/Web/HTTP">HTTP</a></li>
</ul>

<p> </p>
